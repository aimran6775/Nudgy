//
//  InlineMicroSteps.swift
//  Nudge
//
//  Inline micro-step expansion that appears directly under a task card.
//  Shows 2-3 tiny concrete steps generated by AI, with checkable items.
//
//  ADHD research backing:
//  â€¢ Task initiation is the #1 executive function deficit (Barkley, 2012)
//  â€¢ "Just the first step" lowers activation energy dramatically
//  â€¢ Keeping steps visible in-context prevents WM loss from sheet switches
//  â€¢ Checking off micro-steps gives immediate dopamine feedback
//
//  UX: Appears inline with spring animation. Each step has a tap-to-check.
//  Checking all steps = parent task done. No sheet, no context switch.
//

import SwiftUI

// MARK: - Micro Step Model

/// A single micro-step for inline display.
struct MicroStep: Identifiable {
    let id = UUID()
    let content: String
    let emoji: String
    var isComplete: Bool = false
}

// MARK: - Inline Micro Steps View

struct InlineMicroSteps: View {
    
    let parentItem: NudgeItem
    @Binding var steps: [MicroStep]
    let isLoading: Bool
    var onAllComplete: () -> Void
    var onCollapse: () -> Void
    
    @Environment(\.accessibilityReduceMotion) private var reduceMotion
    @State private var appeared = false
    
    private var completedCount: Int {
        steps.filter(\.isComplete).count
    }
    
    private var allComplete: Bool {
        !steps.isEmpty && completedCount == steps.count
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Connector line from parent
            HStack(spacing: 0) {
                Rectangle()
                    .fill(DesignTokens.accentActive.opacity(0.15))
                    .frame(width: 2, height: 12)
                    .padding(.leading, 28)
                Spacer()
            }
            
            VStack(alignment: .leading, spacing: DesignTokens.spacingSM) {
                // Header
                HStack(spacing: DesignTokens.spacingSM) {
                    Image(systemName: "arrow.turn.down.right")
                        .font(.system(size: 10, weight: .semibold))
                        .foregroundStyle(DesignTokens.accentActive)
                    
                    Text(String(localized: "Micro-steps"))
                        .font(.system(size: 11, weight: .semibold))
                        .foregroundStyle(DesignTokens.textSecondary)
                        .textCase(.uppercase)
                    
                    if !steps.isEmpty {
                        Text("\(completedCount)/\(steps.count)")
                            .font(.system(size: 10, weight: .bold, design: .rounded))
                            .foregroundStyle(DesignTokens.accentActive)
                    }
                    
                    Spacer()
                    
                    Button {
                        onCollapse()
                    } label: {
                        Image(systemName: "chevron.up")
                            .font(.system(size: 10, weight: .semibold))
                            .foregroundStyle(DesignTokens.textTertiary)
                            .frame(width: 24, height: 24)
                    }
                    .buttonStyle(.plain)
                }
                
                if isLoading {
                    // Loading skeleton
                    VStack(spacing: DesignTokens.spacingSM) {
                        ForEach(0..<3, id: \.self) { i in
                            HStack(spacing: DesignTokens.spacingSM) {
                                Circle()
                                    .fill(Color.white.opacity(0.04))
                                    .frame(width: 22, height: 22)
                                
                                RoundedRectangle(cornerRadius: 4)
                                    .fill(Color.white.opacity(0.04))
                                    .frame(height: 14)
                                    .frame(maxWidth: [120, 160, 100][i])
                            }
                            .opacity(appeared ? 0.6 : 0.3)
                            .animation(
                                .easeInOut(duration: 1.0)
                                    .repeatForever(autoreverses: true)
                                    .delay(Double(i) * 0.15),
                                value: appeared
                            )
                        }
                    }
                } else {
                    // Steps
                    VStack(spacing: 6) {
                        ForEach($steps) { $step in
                            MicroStepRow(step: $step) {
                                // Check if all are now complete
                                if steps.allSatisfy(\.isComplete) {
                                    // Brief delay then complete parent
                                    Task {
                                        try? await Task.sleep(for: .milliseconds(600))
                                        onAllComplete()
                                    }
                                }
                            }
                        }
                    }
                }
                
                // All-done celebration
                if allComplete {
                    HStack(spacing: DesignTokens.spacingSM) {
                        Text("âœ¨")
                            .font(.system(size: 14))
                        Text(String(localized: "All steps done â€” marking complete!"))
                            .font(.system(size: 12, weight: .medium))
                            .foregroundStyle(DesignTokens.accentComplete)
                    }
                    .padding(.top, 4)
                    .transition(.opacity.combined(with: .scale(scale: 0.9)))
                }
            }
            .padding(DesignTokens.spacingMD)
            .background {
                ZStack {
                    RoundedRectangle(cornerRadius: DesignTokens.cornerRadiusCard)
                        .fill(DesignTokens.cardSurface.opacity(0.25))
                    
                    RoundedRectangle(cornerRadius: DesignTokens.cornerRadiusCard)
                        .strokeBorder(
                            DesignTokens.accentActive.opacity(0.08),
                            lineWidth: 0.5
                        )
                }
            }
        }
        .onAppear { appeared = true }
        .nudgeAccessibilityElement(
            label: String(localized: "Micro-steps for \(parentItem.content), \(completedCount) of \(steps.count) complete")
        )
    }
}

// MARK: - Single Micro Step Row

struct MicroStepRow: View {
    
    @Binding var step: MicroStep
    var onToggle: () -> Void
    
    @Environment(\.accessibilityReduceMotion) private var reduceMotion
    
    var body: some View {
        Button {
            withAnimation(reduceMotion ? .none : .spring(response: 0.3, dampingFraction: 0.7)) {
                step.isComplete.toggle()
            }
            if step.isComplete {
                HapticService.shared.swipeDone()
            } else {
                HapticService.shared.prepare()
            }
            onToggle()
        } label: {
            HStack(spacing: DesignTokens.spacingSM) {
                // Checkbox
                ZStack {
                    Circle()
                        .stroke(
                            step.isComplete ? DesignTokens.accentComplete : Color.white.opacity(0.15),
                            lineWidth: 1.5
                        )
                        .frame(width: 20, height: 20)
                    
                    if step.isComplete {
                        Circle()
                            .fill(DesignTokens.accentComplete)
                            .frame(width: 20, height: 20)
                        
                        Image(systemName: "checkmark")
                            .font(.system(size: 9, weight: .bold))
                            .foregroundStyle(.white)
                    }
                }
                .scaleEffect(step.isComplete ? 1.0 : 0.95)
                
                // Emoji
                Text(step.emoji)
                    .font(.system(size: 14))
                
                // Content
                Text(step.content)
                    .font(.system(size: 13, weight: .medium))
                    .foregroundStyle(
                        step.isComplete ? DesignTokens.textTertiary : DesignTokens.textPrimary
                    )
                    .strikethrough(step.isComplete)
                    .lineLimit(2)
                    .multilineTextAlignment(.leading)
                
                Spacer()
            }
            .padding(.vertical, 6)
            .padding(.horizontal, DesignTokens.spacingSM)
            .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
        .nudgeAccessibility(
            label: "\(step.emoji) \(step.content)",
            hint: step.isComplete
                ? String(localized: "Completed. Double-tap to uncheck")
                : String(localized: "Double-tap to check off"),
            traits: .isButton
        )
    }
}

// MARK: - Micro Step Generator

/// Generates micro-steps using AI (Apple Foundation Models) with a quick fallback.
enum MicroStepGenerator {
    
    /// Generate 2-3 micro-steps for a task.
    /// Tries AI first, falls back to NudgyADHDKnowledge heuristics.
    static func generate(for taskContent: String, emoji: String?) async -> [MicroStep] {
        // Try AI breakdown first
        if AIService.shared.isAvailable {
            do {
                let breakdown = try await AIService.shared.breakDownTask(taskContent)
                // Take first 3 steps max for inline display
                return breakdown.steps.prefix(3).map { step in
                    MicroStep(content: step.task, emoji: step.emoji)
                }
            } catch {
                // Fall through to heuristic
            }
        }
        
        // Heuristic fallback â€” keyword-based micro-steps
        return heuristicSteps(for: taskContent, emoji: emoji)
    }
    
    /// Quick heuristic micro-steps based on task keywords.
    /// Instant, no AI needed â€” always works offline.
    private static func heuristicSteps(for taskContent: String, emoji: String?) -> [MicroStep] {
        let lower = taskContent.lowercased()
        let fallbackEmoji = emoji ?? "ğŸ“Œ"
        
        // Contact-based tasks
        if lower.contains("call") || lower.contains("phone") {
            return [
                MicroStep(content: String(localized: "Open phone app"), emoji: "ğŸ“±"),
                MicroStep(content: String(localized: "Find the contact"), emoji: "ğŸ”"),
                MicroStep(content: String(localized: "Press call"), emoji: "ğŸ“"),
            ]
        }
        
        if lower.contains("text") || lower.contains("message") {
            return [
                MicroStep(content: String(localized: "Open messages"), emoji: "ğŸ’¬"),
                MicroStep(content: String(localized: "Type one sentence"), emoji: "âŒ¨ï¸"),
                MicroStep(content: String(localized: "Hit send"), emoji: "ğŸ“¤"),
            ]
        }
        
        if lower.contains("email") {
            return [
                MicroStep(content: String(localized: "Open email app"), emoji: "ğŸ“§"),
                MicroStep(content: String(localized: "Write subject line"), emoji: "âœï¸"),
                MicroStep(content: String(localized: "Send it"), emoji: "ğŸ“¤"),
            ]
        }
        
        // Shopping/errands
        if lower.contains("buy") || lower.contains("pick up") || lower.contains("get") {
            return [
                MicroStep(content: String(localized: "Add to shopping list"), emoji: "ğŸ“"),
                MicroStep(content: String(localized: "Go to the store"), emoji: "ğŸª"),
                MicroStep(content: String(localized: "Grab it & checkout"), emoji: "âœ…"),
            ]
        }
        
        // Scheduling
        if lower.contains("schedule") || lower.contains("book") || lower.contains("appointment") {
            return [
                MicroStep(content: String(localized: "Look up the number"), emoji: "ğŸ”"),
                MicroStep(content: String(localized: "Pick a date/time"), emoji: "ğŸ“…"),
                MicroStep(content: String(localized: "Confirm booking"), emoji: "âœ…"),
            ]
        }
        
        // Reading/studying
        if lower.contains("read") || lower.contains("study") || lower.contains("article") {
            return [
                MicroStep(content: String(localized: "Open it"), emoji: "ğŸ“–"),
                MicroStep(content: String(localized: "Read just the first paragraph"), emoji: "ğŸ‘€"),
                MicroStep(content: String(localized: "Decide: keep going or save"), emoji: "ğŸ¤”"),
            ]
        }
        
        // Generic fallback â€” the ADHD "just start" pattern
        return [
            MicroStep(content: String(localized: "Open what you need"), emoji: "ğŸ“‚"),
            MicroStep(content: String(localized: "Do the first tiny piece"), emoji: fallbackEmoji),
            MicroStep(content: String(localized: "You're done enough for now"), emoji: "ğŸ§"),
        ]
    }
}

// MARK: - Preview

#Preview("Micro Steps â€” Loading") {
    ZStack {
        Color.black.ignoresSafeArea()
        
        let item = NudgeItem(content: "Email landlord about lease", emoji: "ğŸ“§", sortOrder: 1)
        
        InlineMicroSteps(
            parentItem: item,
            steps: .constant([]),
            isLoading: true,
            onAllComplete: {},
            onCollapse: {}
        )
        .padding()
    }
    .preferredColorScheme(.dark)
}

#Preview("Micro Steps â€” Loaded") {
    ZStack {
        Color.black.ignoresSafeArea()
        
        let item = NudgeItem(content: "Email landlord about lease", emoji: "ğŸ“§", sortOrder: 1)
        
        InlineMicroSteps(
            parentItem: item,
            steps: .constant([
                MicroStep(content: "Open email app", emoji: "ğŸ“§"),
                MicroStep(content: "Write subject line", emoji: "âœï¸"),
                MicroStep(content: "Send it", emoji: "ğŸ“¤"),
            ]),
            isLoading: false,
            onAllComplete: {},
            onCollapse: {}
        )
        .padding()
    }
    .preferredColorScheme(.dark)
}
